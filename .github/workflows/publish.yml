name: Publish release when tag lands on main

on:
  push:
    branches: ['main']

permissions:
  contents: write
  id-token: write

# Avoid duplicate publishes if multiple pushes land quickly
concurrency:
  group: publish-release
  cancel-in-progress: false

jobs:
  check-branch:
    runs-on: ubuntu-latest
    outputs:
      should_publish_any: ${{ steps.branch.outputs.should_publish_any }}
      should_publish_crate: ${{ steps.branch.outputs.should_publish_crate }}
      should_publish_release: ${{ steps.branch.outputs.should_publish_release }}
      reason: ${{ steps.branch.outputs.reason }}
      tag: ${{ steps.branch.outputs.tag }}
    steps:
      - name: Checkout (full history incl. tags)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - id: branch
        name: Choose newest publishable tag reachable from main
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        shell: bash
        run: |
          set -euo pipefail

          echo "Default branch: $DEFAULT_BRANCH"
          git rev-parse "origin/$DEFAULT_BRANCH" >/dev/null

          # Find highest semver v* tag whose commit is an ancestor of main
          candidate_tag=""
          while IFS= read -r t; do
            if git merge-base --is-ancestor "$(git rev-parse "$t")" "origin/$DEFAULT_BRANCH"; then
              candidate_tag="$t"
              break
            fi
          done < <(git tag -l 'v*' --sort=-v:refname)

          if [[ -z "${candidate_tag}" ]]; then
            echo "should_publish_any=false" >> "$GITHUB_OUTPUT"
            echo "should_publish_crate=false" >> "$GITHUB_OUTPUT"
            echo "should_publish_release=false" >> "$GITHUB_OUTPUT"
            echo "reason=no release tags reachable from $DEFAULT_BRANCH" >> "$GITHUB_OUTPUT"
            echo "tag=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Determine crate publish eligibility. Fail CLOSED for crate publish
          # on crates.io network/parse issues, but keep evaluating GitHub
          # release publication independently.
          crate_name="$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].name')"
          tag_version="${candidate_tag#v}"

          check_url="https://crates.io/api/v1/crates/${crate_name}"
          tmp="$(mktemp)"
          trap 'rm -f "$tmp"' EXIT

          should_publish_crate=true
          crate_status_note=""
          if ! curl -fsS \
                --connect-timeout 5 \
                --max-time 15 \
                --retry 5 \
                --retry-delay 2 \
                --retry-all-errors \
                -H "User-Agent: curl" \
                -o "$tmp" "$check_url"; then
            should_publish_crate=false
            crate_status_note="crate publish disabled: crates.io check unreachable"
          elif ! jq -e . "$tmp" >/dev/null 2>&1; then
            should_publish_crate=false
            crate_status_note="crate publish disabled: crates.io response not parseable"
          elif jq -e --arg v "$tag_version" 'any(.versions[]?; .num == $v)' "$tmp" >/dev/null 2>&1; then
            should_publish_crate=false
            crate_status_note="crate version ${tag_version} already on crates.io"
          fi

          # Check whether a GitHub release exists for the same tag.
          # Treat lookup transport failures as "do not publish release now"
          # rather than crashing this selection step.
          release_api="https://api.github.com/repos/${{ github.repository }}/releases/tags/${candidate_tag}"
          should_publish_release=true
          release_status_note=""
          if ! release_status="$(curl -sS -o /dev/null -w '%{http_code}' \
            --connect-timeout 5 \
            --max-time 15 \
            --retry 5 \
            --retry-delay 2 \
            --retry-all-errors \
            -H 'Accept: application/vnd.github+json' \
            -H 'User-Agent: curl' \
            "$release_api")"; then
            should_publish_release=false
            release_status_note="GitHub release lookup unreachable"
          elif [[ "$release_status" == "200" ]]; then
            should_publish_release=false
            release_status_note="GitHub release for ${candidate_tag} already exists"
          elif [[ "$release_status" != "404" ]]; then
            should_publish_release=false
            release_status_note="GitHub release lookup returned HTTP ${release_status}"
          fi

          should_publish_any=false
          if [[ "$should_publish_crate" == "true" || "$should_publish_release" == "true" ]]; then
            should_publish_any=true
          fi

          if [[ "$should_publish_any" == "false" ]]; then
            echo "should_publish_any=false" >> "$GITHUB_OUTPUT"
            echo "should_publish_crate=false" >> "$GITHUB_OUTPUT"
            echo "should_publish_release=false" >> "$GITHUB_OUTPUT"
            reason="no publication needed or possible for ${candidate_tag}"
            if [[ -n "$crate_status_note" ]]; then
              reason="${reason}; ${crate_status_note}"
            fi
            if [[ -n "$release_status_note" ]]; then
              reason="${reason}; ${release_status_note}"
            fi
            echo "reason=${reason}" >> "$GITHUB_OUTPUT"
            echo "tag=${candidate_tag}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_publish_any=true"  >> "$GITHUB_OUTPUT"
          echo "should_publish_crate=${should_publish_crate}" >> "$GITHUB_OUTPUT"
          echo "should_publish_release=${should_publish_release}" >> "$GITHUB_OUTPUT"
          reason="tag ${candidate_tag} is on ${DEFAULT_BRANCH}; publication pending"
          if [[ -n "$crate_status_note" ]]; then
            reason="${reason}; ${crate_status_note}"
          fi
          if [[ -n "$release_status_note" ]]; then
            reason="${reason}; ${release_status_note}"
          fi
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "tag=${candidate_tag}" >> "$GITHUB_OUTPUT"

      - name: Summary
        run: |
          {
            echo "### Publish on tag â€” selection"
            echo "- Tag: \`${{ steps.branch.outputs.tag || 'n/a' }}\`"
            echo "- Should publish anything: **${{ steps.branch.outputs.should_publish_any }}**"
            echo "- Should publish crate: **${{ steps.branch.outputs.should_publish_crate }}**"
            echo "- Should publish GitHub release: **${{ steps.branch.outputs.should_publish_release }}**"
            echo "- Reason: ${{ steps.branch.outputs.reason }}"
          } >> "$GITHUB_STEP_SUMMARY"

  publish-crate:
    needs: check-branch
    if: needs.check-branch.outputs.should_publish_crate == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (need tags)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check out tagged commit
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ needs.check-branch.outputs.tag }}"
          echo "Checking out ${TAG}"
          git checkout --quiet "$TAG"

      - name: Show Rust toolchain
        run: |
          rustup --version
          rustc -V
          cargo -V

      - name: Verify tag matches crate version
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ needs.check-branch.outputs.tag }}"
          TAG_VERSION="${TAG#v}"
          CRATE_VERSION="$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')"
          [ "$TAG_VERSION" = "$CRATE_VERSION" ] || {
            echo "Tag v$TAG_VERSION does not match Cargo.toml version $CRATE_VERSION"
            exit 1
          }

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libdbus-1-dev pkg-config

      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          cargo publish --locked --dry-run
          cargo publish --locked

  build-binaries:
    needs: check-branch
    if: needs.check-branch.outputs.should_publish_release == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive_ext: tar.gz
          - os: macos-15-intel
            target: x86_64-apple-darwin
            archive_ext: tar.gz
          - os: macos-15
            target: aarch64-apple-darwin
            archive_ext: tar.gz
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive_ext: zip
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check out tagged commit
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ needs.check-branch.outputs.tag }}"
          git checkout --quiet "$TAG"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install Linux system dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libdbus-1-dev pkg-config

      - name: Build release binary
        run: cargo build --locked --release --target ${{ matrix.target }}

      - name: Smoke test binary (Linux/macOS)
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.target }}
        shell: bash
        run: |
          BIN="target/$TARGET/release/chabeau"
          "$BIN" --version
          "$BIN" --help > /dev/null

      - name: Smoke test binary (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $bin = "target/${{ matrix.target }}/release/chabeau.exe"
          & $bin --version
          & $bin --help | Out-Null

      - name: Package release archive (Linux/macOS)
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.target }}
          TAG: ${{ needs.check-branch.outputs.tag }}
        shell: bash
        run: |
          set -euo pipefail
          BIN_DIR="target/$TARGET/release"
          ASSET_TARGET="$TARGET"
          ASSET_TARGET="${ASSET_TARGET/-unknown-/-}"
          ARCHIVE="chabeau-${TAG}-${ASSET_TARGET}.tar.gz"
          tar -C "$BIN_DIR" -czf "$ARCHIVE" chabeau
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum "$ARCHIVE" > "$ARCHIVE.sha256"
          else
            shasum -a 256 "$ARCHIVE" > "$ARCHIVE.sha256"
          fi

      - name: Package release archive (Windows)
        if: runner.os == 'Windows'
        env:
          TAG: ${{ needs.check-branch.outputs.tag }}
        shell: pwsh
        run: |
          $assetTarget = "${{ matrix.target }}".Replace("-pc-", "-")
          $archive = "chabeau-$env:TAG-$assetTarget.zip"
          Compress-Archive -Path "target/${{ matrix.target }}/release/chabeau.exe" -DestinationPath $archive -Force
          $hash = (Get-FileHash -Algorithm SHA256 $archive).Hash.ToLower()
          "$hash  $archive" | Out-File -Encoding ascii "$archive.sha256"

      - name: Upload packaged artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: |
            chabeau-${{ needs.check-branch.outputs.tag }}-*.tar.gz
            chabeau-${{ needs.check-branch.outputs.tag }}-*.tar.gz.sha256
            chabeau-${{ needs.check-branch.outputs.tag }}-*.zip
            chabeau-${{ needs.check-branch.outputs.tag }}-*.zip.sha256

  publish-release:
    needs: [check-branch, build-binaries]
    if: needs.check-branch.outputs.should_publish_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download packaged artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: release-*
          merge-multiple: false

      - name: Build combined checksum file
        env:
          TAG: ${{ needs.check-branch.outputs.tag }}
        run: |
          set -euo pipefail
          find dist/release-* -type f -name "chabeau-${TAG}-*.sha256" -print0 \
            | sort -z \
            | xargs -0 cat > dist/SHA256SUMS

      - name: Install cosign
        uses: sigstore/cosign-installer@v3

      - name: Sign checksum manifest (keyless)
        run: |
          set -euo pipefail
          cosign sign-blob --yes \
            --output-signature dist/SHA256SUMS.sig \
            --output-certificate dist/SHA256SUMS.pem \
            dist/SHA256SUMS

      - name: Build release notes from changelog
        env:
          TAG: ${{ needs.check-branch.outputs.tag }}
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${TAG#v}"
          NOTES_FILE="dist/RELEASE_NOTES.md"

          {
            echo "## Chabeau ${TAG}"
            echo
            echo "Automated release artifacts for \`${TAG}\`."
            echo
          } > "$NOTES_FILE"

          section="$(awk -v ver="$VERSION" '
            $0 == "## " ver { in_sec=1; print; next }
            in_sec && /^## / { exit }
            in_sec { print }
          ' CHANGELOG.md)"

          if [[ -n "$section" ]]; then
            printf '%s\n' "$section" >> "$NOTES_FILE"
            echo >> "$NOTES_FILE"
            echo "_Release notes extracted from CHANGELOG.md._" >> "$NOTES_FILE"
          else
            {
              echo "### Notes"
              echo "- See CHANGELOG.md for a full history of changes."
            } >> "$NOTES_FILE"
          fi

      - name: Publish or update GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-branch.outputs.tag }}
          name: Chabeau ${{ needs.check-branch.outputs.tag }}
          body_path: dist/RELEASE_NOTES.md
          files: |
            dist/release-*/chabeau-${{ needs.check-branch.outputs.tag }}-*.tar.gz
            dist/release-*/chabeau-${{ needs.check-branch.outputs.tag }}-*.zip
            dist/release-*/chabeau-${{ needs.check-branch.outputs.tag }}-*.tar.gz.sha256
            dist/release-*/chabeau-${{ needs.check-branch.outputs.tag }}-*.zip.sha256
            dist/SHA256SUMS
            dist/SHA256SUMS.sig
            dist/SHA256SUMS.pem
            dist/RELEASE_NOTES.md
          overwrite_files: true
